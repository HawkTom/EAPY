from function import continueFunction as cF
import numpy as np
import time
import sys
import copy


class GL25:

    def __init__(self):
        self.Name = "GL25"
        self.FERuntime = 0
        self.FENum = 0
        self.setParameters()

    def setParameters(self):
        pass

    def optimize(self, cfp, ap, printLog=True):
        runtimeStart = time.clock()
        self.mainLoop(cfp, ap, printLog)
        self.runtime = time.clock() - runtimeStart

    def mainLoop(self, cfp, ap, printLog):
        np.random.seed(ap.initialSeed)
        # popSize = ap.poplationSize
        popSize = 400
        Dim = cfp.funcDim
        function = getattr(cF, cfp.funcName)
        lowerBoundX = np.kron(np.ones((popSize, 1)), cfp.funcLowerBound)
        upperBoundX = np.kron(np.ones((popSize, 1)), cfp.funcUpperBound)

        lowerInitBoundX = np.kron(
            np.ones((popSize, 1)), cfp.funcInitLowerBound)
        upperInitBoundX = np.kron(
            np.ones((popSize, 1)), cfp.funcInitUpperBound)

        # initial male group of the global search 
        GM = (upperInitBoundX - lowerInitBoundX) * \
            np.random.random_sample((popSize, Dim)) + lowerInitBoundX
        start = time.clock()
        GM_fit = function(GM)
        self.FERuntime += (time.clock()-start)
        self.FENum += popSize
        
        # initialize the femal group of the global search
        indexSort = np.argsort(GM_fit)
        GF = copy.copy(GM[indexSort[0: 200], :])
        GF_fit = copy.copy(GM_fit[indexSort[0: 200]])
        # record the number of offspring generated by the femal parent
        numTimesMother = np.zeros((200, 1))

        # Judge the global search or the local search: J = 0 means the global
        # search and J = 1 means the local search
        J = 0
        while self.FENum < ap.FEMax:

            if (self.FENum > ap.FEMax * 0.25) and (J == 0):
                popSize = 100
                fitindex = np.argsort(GM_fit)
                fitval = np.sort(GM_fit)
                # initialize the male group of the local search
                GM = GM[fitindex[0:100], :]
                GM_fit = GM_fit[fitindex[0:100]]
                # initialize the female group of the local search
                GF = copy.copy(GM[0:5, :])
                GF_fit = copy.copy(GM_fit[0:5])
                # update the number of offspring generated by the femal
                numTimesMother = np.zeros((5, 1))
                J = 1
            
            # uniformal fertility selection (UFS)
            timesindex = np.argmin(numTimesMother)
            mother = GF[timesindex, :]
            mother_fit = GF_fit[timesindex]

            numTimesMother[timesindex] = numTimesMother[timesindex] + 1

            # negatively assortiative amating
            temp = np.floor(np.random.random_sample((1, 5)) * popSize)
            temp = temp[0, :].astype(int)
            temp_father = GM[temp, :]
            temp_father_fit = GM_fit[temp]
   
            Edistance = np.sum(np.power(np.kron(np.ones((5, 1)), mother) - temp_father, 2), 1)

            Edistanceindex = np.argmax(Edistance)
            father = temp_father[Edistanceindex, :]
            father_fit = temp_father_fit[Edistanceindex]

            # PBX-alpha
            temp = np.abs(mother - father)
            L = np.amax(np.vstack((cfp.funcLowerBound, mother - temp*0.8)), axis=0)
            U = np.amin(np.vstack((cfp.funcUpperBound, mother + temp*0.8)), axis=0)
            offspring = L + np.random.random_sample((1, Dim)) * (U - L)

            # evaluation       
            start = time.clock()                    
            offspring_fit = function(offspring)
            self.FERuntime += (time.clock()-start)
            self.FENum += 1

            # replace the worst individual in the population
            if offspring_fit < mother_fit:
                fitindex = np.argmax(GM_fit)
                GM[fitindex, :] = mother
                GM_fit[fitindex] = mother_fit

                GF[timesindex, :] = offspring
                GF_fit[timesindex] = offspring_fit

                numTimesMother[timesindex] = 0
            elif offspring_fit < np.max(GM_fit):
                fitindex = np.argmax(GM_fit)
                GM[fitindex, :] = offspring
                GM_fit[fitindex] = offspring_fit
                 
        self.optimalX = GM[np.argmin(GM_fit), :]
        self.optimalY = np.min(GM_fit)
        if printLog:
            # summary
            print('$--------Result--------$\n')
            print('*Function: {0}\tDimension: {1}\t FEMax: {2}\n'.format(
                cfp.funcName, cfp.funcDim, self.FENum))
            print('Optimal Y  : {0} \n'.format(self.optimalY))  


